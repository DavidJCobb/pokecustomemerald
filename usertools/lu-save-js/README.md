
This tool is intended to be a web-based utility for dumping the contents of a savegame, given the `.sav` file and the `.xml` file (generated by the `lu_bitpack` compiler plug-in) which describes the bitpacked file format. This is useful both as a debugging aid, and as a means to upgrade a savegame from an older save file format to a newer one, allowing players to install updated versions of the game and continue playthroughs started pre-update. The tool is built in JavaScript to allow it to be web-hosted, either as a full save editor, or possibly as a stripped-down web application that only updates savegames across serialization formats.

# Internals

## Architecture

The architecture is as follows:

* Elements of the save file format
  * `CStructDefinition` and `CUnionDefinition` map to XML elements in `c-types`; in essence, they are struct and union definitions.
  * `CDeclDefinition` maps to `decl_descriptor`s in the plug-in; in essence, they are variables and struct/union members.
* Elements of an actual save file, as represented in JS
  * `CStructInstance` and `CUnionInstance` are instances of structs and unions.
  * `CValueInstance` is a serialized value. `CArrayInstance` is an array (whether of values, struct/union instances, or other arrays).
  * ~~As a lazy hack~~ For convenience, save slots subclass `CStructInstance`, with top-level to-be-serialized variables treated as members of this imaginary struct.

Loading data from a bitpacked save works by: spawning an `InstructionsApplier`; feeding it an appropriate `SaveFormat`, root data object (the "target"), bitstream; and applying it to an `<instructions />` node:

* To read a sector, have your applier target a nameless `CStructInstance` whose members are the top-level values in the bitstream. Have the bitstream wrap the given sector of flash memory.
* When processing a `SingleInstructionNode`, you may find that the node's `type` is `"struct"`. In that case, you're dealing with a whole struct. Loop up the appropriate `CStruct`, find its `<instructions />` node, and spawn a new `InstructionsApplier` whose target is the struct instance. Have it reuse the same bitstream as the original `InstructionsApplier`.

One of our desired features is the ability to translate bitpacked data from one save format to another. This process is internally called *translation*, and is performed by spawning and running a `TranslationOperation` on a `SaveSlot`. Prior to running the operation, you can attach *user-defined translators* to it to handle cases where data can't be translated automatically (e.g. fields that have been redesigned, restructured, etc.). See `DATA TRANSLATION.md`.


## Extra data

This branch includes a post-build Lua script which uses GCC to dump the values of several preprocessor macros of interest &mdash; generally preprocessor-based enums like Pokemon species names and move names. The Lua script will generate extra-data files (file extension `.dat`) for the current serialization version (`SAVEDATA_SERIALIZATION_VERSION` macro). For example, if `SAVEDATA_SERIALIZATION_VERSION` is `#define`d as `3`, then we generate `.dat` files in `lu-save-js/formats/3/`.

(For more information on the post-build script and the extra-data file format, see the `lu-save-js-indexer` tool folder.)

Our JavaScript code is capable of reading these extra-data files and using them to influence the display and editing of various pieces of savedata in the UI. For example, integers that use the `PokemonSpeciesID` typedef will have their values displayed using the appropriate preprocessor names, e.g. `1` is displayed as `SPECIES_BULBASAUR`, and these names are retrieved from the extra-data files. If you were to modify the species list, replace Bulbasaur with something else[^bulbasaur], and rename the preprocessor macro, then your new name would be displayed in the UI instead (provided it starts with `SPECIES_`).

[^bulbasaur]: But why would you want to? Bulbasaur is cute.

## Rendering

My initial desire was to render the tree of loaded data as custom elements, for ease of implementation. Unfortunately, however, the DOM just fundamentally can't handle that much content; Firefox, at the very least, slowed to a crawl and the browser tab became nearly inoperable when I tried.

As such, we render the data table as a canvas, with custom implementations of sizing, layout, hitboxes, and so on. The `TreeRowViewElement` handles all of the rendering logic, and is subclassed by `CViewElement` for displaying this tool's specific data. `TreeRowViewElement` receives tree items via subclasses of `TreeRowViewModel`; if you've done GUI programming using Qt, you should be familiar with this approach.


### Click hitboxes

The custom element needs to know what rows were rendered, and what hitboxes exist within them, in order to handle clicks on rows' expand/collapse "twisty" icons whenever such icons are present. To enable this, we maintain a list of all rows that were rendered on the last repaint, describing their sizes, positions, the data items being rendered, and any hitboxes of note.


### Tooltips

When a cell's content is truncated, we give it a tooltip. Tooltips are implemented as absolutely-positioned `div` elements placed overtop the canvas, with `title` attributes.

At the start of the repaint process, we gather up all extant tooltips and store references to them in a map, indexing them by the row and column of the cells they annotate. When a cell needs a tooltip, it checks the map for an existing tooltip; if one is found, it's removed from the map and updated; otherwise, a new tooltip is created and *not* added to the map. Any tooltips still in the map at the end of the repaint process are deleted.