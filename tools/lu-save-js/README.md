
This tool is intended to be a web-based utility for dumping the contents of a savegame, given the `.sav` file and the `.xml` file (generated by the `lu_bitpack` compiler plug-in) which describes the bitpacked file format.

# Internals

## Architecture

The architecture is as follows:

* Elements of the save file format
  * `CStruct` and `CUnion` map to XML elements in `c-types`; in essence, they are struct and union definitions.
  * `CValue` maps to `decl_descriptor`s in the plug-in; in essence, they are variables and struct/union members. A single `CValue` may describe a single serialized value or a serialized array.
* Elements of an actual save file, as represented in JS
  * `CStructInstance` and `CUnionInstance` are instances of structs and unions.
  * `CValueInstance` is a serialized value.
    * Currently, `CValueInstance` is a direct parallel to `CValue`, but this complicates the handling of arrays. I will likely split it into `CValueInstance` for single values and `CValueInstanceArray` for arrays, such that `int foo[3][2]` in C produces one `CValue`, and nested `CValueInstanceArray`s where the innermost ones hold multipel `CValue`s.

Loading data from a bitpacked save works by: spawning an `InstructionsApplier`; feeding it an appropriate `SaveFormat`, root data object (the "target"), bitstream; and applying it to an `<instructions />` node:

* To read a sector, have your applier target a nameless `CStructInstance` whose members are the top-level values in the bitstream. Have the bitstream wrap the given sector of flash memory.
* When processing a `SingleInstructionNode`, you may find that the node's `type` is `"struct"`. In that case, you're dealing with a whole struct. Loop up the appropriate `CStruct`, find its `<instructions />` node, and spawn a new `InstructionsApplier` whose target is the struct instance. Have it reuse the same bitstream as the original `InstructionsApplier`.


## Rendering

My initial desire was to render the tree of loaded data as custom elements, for ease of implementation. Unfortunately, however, the DOM just fundamentally can't handle that much content; Firefox, at the very least, slowed to a crawl and the browser tab became nearly inoperable when I tried.

As such, we render the data table as a canvas, with custom implementations of sizing, layout, hitboxes, and so on; see `CViewElement`.


### Click hitboxes

The custom element needs to know what rows were rendered, and what hitboxes exist within them, in order to handle clicks on rows' expand/collapse "twisty" icons whenever such icons are present. To enable this, we maintain a list of all rows that were rendered on the last repaint, describing their sizes, positions, the data items being rendered, and any hitboxes of note.


### Tooltips

When a cell's content is truncated, we give it a tooltip. Tooltips are implemented as absolutely-positioned `div` elements placed overtop the canvas, with `title` attributes.

At the start of the repaint process, we gather up all extant tooltips and store references to them in a map, indexing them by the row and column of the cells they annotate. When a cell needs a tooltip, it checks the map for an existing tooltip; if one is found, it's removed from the map and updated; otherwise, a new tooltip is created and *not* added to the map. Any tooltips still in the map at the end of the repaint process are deleted.